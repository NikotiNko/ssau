// Labs3.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include "windows.h"
#include "iostream"
#include "fstream"
#include "iomanip"

using namespace std;

long double resultASM(long double &a,long double &c,long double &d) {//функция считает выражение ( c - d / 2 + 33 ) / ( 2 * a * a - 1 )
	double a1 = a, c1 = c, d1 = d;                 //через параметр а будем возвращать было деление на 0
	double nege = -0.5;							   //через параметр с будем возвращать получилось ли в ходе  решения особое число
	double tt = 33.0;
	double dva = 2;
	bool fZero = false; //флаг переполнения или деления на 0
	bool fOver = false;
	bool fNan = false;
	__asm{
		finit; //инициализируем сопроцессор					st   |st(1)   |st(2)    ...   st(7)
		
		//считаем числитель										 |		  |
		fld d1;//											d    |		  |
		fld nege;//										   -0.5  |  d	  |
		fmulp st(1), st; //    							   -d/2	 |		  |
		
        //может получиться денормолизованное число, , поэтому проверяем не получилось ли оно
		fxam; //анализ содержимого и определение типа числа в st
		fstsw ax;//сохраняем регистр состояний со процессора в ax
		test ax, 10b;
		jnz fENan;//если да, то получили денормализованное число и переходим на соответствующую метку
		
		fld c1;//											c	 | -d/2	  |
		faddp st(1), st; //								   c-d/2 |		  |

		fstp nege; //чтобы установился флаг переполнения(если оно вообще было)
		fld nege; //необходимо достать из стека и положить обратно результат предыдущей операции
		fstsw ax;
		test ax, 1000b;//проверяем было ли переполнение
		jnz fEOver;//если было переходим на соотвествующую метку
		
		fld tt;//                                            33  | c-d/2  |
		faddp st(1), st; //								c-d/2+33 |		  |				
		
		fstp nege; //чтобы установился флаг переполнения(если оно вообще было)
		fld nege; //необходимо достать из стека и положить обратно результат предыдущей операции
		fstsw ax;
		test ax, 1000b;//проверяем было ли переполнение
		jnz fEOver;//если было переходим на соотвествующую метку 
		
		//считаем знаменатель									 |        |
		fld a1;//											a    |c-d/2+33|
		fld a1;//											a	 |   a    |c-d/2+33
		fmulp st(1), st; //    								a*a  |c-d/2+33|
		
		fstp nege; //чтобы установился флаг переполнения(если оно вообще было)
		fld nege; //необходимо достать из стека и положить обратно результат предыдущей операции
		fstsw ax;
		test ax, 1000b;//проверяем было ли переполнение
		jnz fEOver;//если было переходим на соотвествующую метку
		
		fld dva;//											2    |  a*a   |c-d/2+33
		fmulp st(1), st; //									2*a*a|c-d/2+33|
		
		fstp nege; //чтобы установился флаг переполнения(если оно вообще было)
		fld nege; //необходимо достать из стека и положить обратно результат предыдущей операции
		fstsw ax;
		test ax, 1000b;//проверяем было ли переполнение
		jnz fEOver;//если было переходим на соотвествующую метку
		
		fld1;//												1	 |2*a*a	  |c-d/2+33
		fsubp st(1), st;//								  2*a*a-1|c-d/2+33|
		ftst;//сравниваем знаменатель c нулем
		fstsw ax;
		sahf; //сохраняем регистр состояний в регистр флагов
		je fEZero; //если == 0 то переходим на соответствующую метку
		//делим числитель на знаменатель	
		fdivp st(1), st;//					 (c-d/2+33)/(2*a*a-1)|		  |		
		jmp fend;
	fEZero://сюда переходим если было деление на 0
		inc fZero;//поднимаем свой флаг переполнения или деления на 0
		jmp fend;
	fEOver:
		inc fOver;
		jmp fend;
	fENan:
		inc fNan;
	fend:

	}
	if (fZero) {//возможные ошибки возникающие в ходе вычисления возвращаются через параметры которые переданы в функцию
		++a;	//если было деление на 0, то увеличиваем а на единицу
	}
	if (fOver) {
		++c;	//если было переполнение, то увеличиваем с на единицу
	}
	if (fNan) {
		++d;	//если получили особое число, то увеличиваем d на единицу
	}
}

long double result(long double a,long double c,long double d) {//функция вычисление выражения на с++
		return (c - d / 2 + 33) / (2 * a * a - 1);
}

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "rus");
	long double a, c, d, a1, c1, d1;
	ifstream fin;
	fin.open("C:\\Users\\vlad\\Desktop\\условие.txt");
	cout << "Вариант №13" << endl;
	cout << "Программа реализовывает функцию вычисления целочисленного выражения на встроенном ассемблере." << endl;
	cout << "Выражение: ( c - d / 2 + 33 ) / ( 2 * a * a - 1 )" << endl;
	cout << "Все параметры функции 32 битные целые числа." << endl;
	cout << "Числа хранятся в текстовом файле <условие.txt>, который находится на Раб. столе." << endl;
	cout << "Ответ выводится на экран в соотвествии с заданием" << endl;
	if (fin.is_open()) {
		while (!fin.eof()) {
			fin >> a >> c >> d;
			a1 = a;
			c1 = c;
			d1 = d;
			int kol = 12;
			double r = resultASM(a, c, d);
			cout << "Для чисел a = " << a1 << " c = " << c1 << " d = " << d1 << endl;
			if (a == a1) {
				if (c == c1) {
					if (d == d1) {
						cout << "Значение функции посчитано на встроенном ассемблере" << endl;
						cout << setprecision(kol) << r << endl;
						cout << "Значение функции посчитано обычной функцией" << endl;
						cout << setprecision(kol) << result(a1, c1, d1) << endl << endl;
					}
					else {
						cout << "Получили особое число" << endl << endl;
					}
				}
				else {
					cout << "Ошибка: произошло переполнение" << endl << endl;
				}
			}
			else {
				cout << "Ошибка: произошло деление на 0" << endl << endl;
			}
			
		}
	}
	else {
		cout << "Ошибка открытия файла" << endl;
	}
	system("pause");
	return 0;
}