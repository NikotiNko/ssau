// Labs3.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include "windows.h"
#include "iostream"
#include "fstream"

using namespace std;

bool resault(int a, int b, int &c) {//функция считает выражение (a+c/b-28)/(4*a*b+1)
	bool f=false; // флагом сигнализируем о переполнении
	int m = c; //результат вычисления выражения будет передан из функции в параметре c
	__asm{
		mov eax, m; //eax = c 
		cdq;  // раширяем
		idiv b; //eax = c/b
		mov edx, eax; //заполняем регистр edx значениями бита знака результата выражения c/b
		sar edx, 31;
		mov ecx, a;	//ecx = a, чтобы не было переполнения задействуем 2 регистра
		sar ecx, 31; // ecx состоит из значений флага знака, после предыдущей операции 
		add eax, a; //складываем младшие части
		adc edx, ecx; //складываем старшие части <edx:eax> =  a + c / b
		xor ecx, ecx; //в регистре ecx будет "старшая" часть числа 28
		sub eax, 28; // вычитаем младшие части числа
		sbb edx, ecx; //<edx:eax> =  a + c / b - 28 
		push edx;
		push eax; //запоминаем результат выражения a + c / b - 28
		mov eax, a; //eax = a
		imul b;// <edx:eax> = a * b //возможно переполнение
		jno metka1;
		inc f; //если было переполнение переходим на эту строчку и устанавливаем флаг, если не было то пропускаем эту строчку
	metka1: 
		sal eax, 2; //eax = 4*a*b
		jno metka2;
		inc f; //если было переполнение переходим на эту строчку и устанавливаем флаг, если не было то пропускаем эту строчку
	metka2:
		inc eax; // eax = 4*a*b+1
		//тут не будет переполнения, т.к. 4*a*b это будет четное число
		//а максимально возможное число для типа int 2147483647 - нечетное, если не было переполнения раньше максимально возможное
		//число, которое можно получить 2147483646, до операции инкремента
		mov ecx, eax; // ecx = eax
		pop eax; //готовимся к делению
		pop edx; //извлекаем результат первой скобки из стека
		idiv ecx; // eax = ( a + c / b - 28 ) / ( 4 * a * b + 1 )
		mov m, eax;
	}
	c = m;
	return f;
}

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(LC_ALL, "rus");
	int a, b, c, a1;
	ofstream fout;
	ifstream fin;
	fout.open("C:\\Users\\vlad\\Desktop\\ответ.txt");
	fin.open("C:\\Users\\vlad\\Desktop\\условие.txt");
	cout << "Вариант №31" << endl;
	cout << "Программа реализовывает функцию вычисления целочисленного выражения на встроенном ассемблере." << endl;
	cout << "Выражение: (a + b / c - 28) / (4 * b * a + 1)" << endl;
	cout << "Все параметры функции 32 битные целые числа." << endl;
	cout << "Числа хранятся в текстовом файле <условие.txt>, который находится на Раб. столе." << endl;
	cout << "Ответ записывается в текстовый файл <ответ.txt>, который находится на Раб. столе" << endl;
	if (fin.is_open()) {
		while (!fin.eof()) {
			fin >> a >> b >> c;
			a1 = c;
			while (!b) {
				cout << " Возможно деление на ноль, введети новое значение для переменной" << endl;
				cin >> b;
			}
			if (!resault(a, b, c)) {	
				fout << c << endl;
			}
			else{
				fout << "Переполнение" << endl;
			}
			//cout << ((a + c / b - 28) / (4 * a * b + 1)) << endl;
		}
	}
	else {
		cout << "Ошибка открытия файла" << endl;
	}
	system("pause");
	return 0;
}

